-------------------------General-Purpose iShadow Driver------------------------

This is the primary firmware for the iShadow glasses. For most purposes you should be able to accomplish everything you need to do by just commenting / uncommenting the various #define flags in stonyman_conf.h. Specific descriptions for what each flag does can be found here.

If for some reason you want to modify the code directly, you can find a small overview of the firmware architecture at the end of this readme.



--------------------------------Getting Started--------------------------------

To begin, open the ishadow_driver.eww file in the IAR IDE. This will load the project with all necessary settings already configured for you.

To load firmware, connect the ST-LINK programmer to the glasses as described in the primary readme. Make sure that both the programmer and the glasses themselves are connected to the machine via USB. Then, hit the "Download and Debug" button in IAR.

Once the firmware is loaded, you can run it directly in debug mode as you would any program on a computer. If you disconnect the programmer and power-cycle the glasses, they will begin running the firmware as soon as they power back on.

***IMPORTANT***
If you are writing to the SD card, make sure that you remove it before restarting the glasses, as they will automatically begin overwriting existing data from the beginning of the card upon powering back up.



------------------------------Configuration Flags------------------------------

---USB_SEND---
Sets the glasses to send data to a computer via USB, to be read using usb_image.py. Note that even if DUAL_CAMERA is selected (TODO: add this and single_camera flags), only the video from the camera that is selected as primary will be transmitted over USB. The other camera will still be read from and could potentially be used for some kind of feedback even if it's not transmitted.

Note that, for simplicity, the glasses are configured to appear to the host as a USB microphone. This shouldn't affect you in any way provided you're using the drivers correctly, but just FYI.

This option cannot be selected at the same time as SD_SEND.


---SD_SEND---
Sets the glasses to send data to the onboard SD card, to be read using unpack_images.py. If DUAL_CAMERA is selected, data from both cameras will be stored on the card, though you may need to remember which camera is selected as primary to avoid confusion when extracting the video.

***IMPORTANT***: The SD driver has no way of knowing where it is safe to start writing data if you power-cycle the glasses. Thus, if you are in SD mode, every time you turn on the glasses they will start writing data from the beginning of the card, potentially overwriting existing data. We recommend that you disconnect the glasses from power when you are done with data collection and remove the card before powering them back on.

This option cannot be selected at the same time as USB_SEND.


---EYE_CAM_PRIMARY and OUT_CAM_PRIMARY---
Used to select whether the eye-facing or out-facing camera is the primary. The primary camera is the only one that will be recorded if using SINGLE_CAMERA mode.

In DUAL_CAMERA mode, exact behavior depends on the data send setting. For USB, the primary camera is the only one that will be streamed to the computer, though the MCU will still technically be collecting video from both cameras. For SD, both cameras will be recorded and unpack_images.py will label the primary and secondary camera feeds as such.

If CIDER_MODE or ANN_MODE is selected, EYE_CAM_PRIMARY will be forcibly set.


---USE_PARAM_FILE---
Indicates that a parameter file is being loaded which includes FPN mask(s) and possibly parameters for the eye tracking models. To select a file to load into the firmware, do the following:

1. In IAR, open Project Options (Alt-F7, right-click on the project name, or Project->Options), select the "Linker" category, and then the "Input" tab

2. In the "Raw binary image" section, fill in the fields as follows:
	->File: select your binary data file (generated by build_param_file.py)
	->Symbol: model_data
	->Section: model_section
	->Align: 1

Since loading a binary file slows down the programming process, we recommend that you clear these fields if you will not be using this flag.

If CIDER_MODE or ANN_MODE is selected, this flag will be forcibly set. If you receive linker errors about a missing definition for "model_data", it is because this file is missing.


TODO: Add flags for generating FPN mask pairs


---COLUMN_COLLECT---
This is an advanced option that affects how the Stonyman accesses the pixels. This is on by default and should be left on unless you have a compelling reason to change it.

If CIDER_MODE or ANN_MODE is selected, this flag will be forcibly set.


---ANN_MODE---
Will run the eye tracking algorithm with only the ANN (no CIDER cross model). This flag assumes that you have loaded the ANN parameters into the binary file using build_param_file.py, along with the FPN masks for the eye-facing camera at least. Out-facing FPN mask is not technically necessary but recommended nonetheless.

The results of the ANN model for eye tracking will be stored along with the images. usb_image.py will look for these data automatically, if you are using unpack_images.py you must manually set the --model-data flag.

Setting ANN_MODE or CIDER_MODE forces the following flags to be set:
->EYE_CAM_PRIMARY
->USE_PARAM_FILE
->COLUMN_COLLECT


---CIDER_MODE---
Will run the eye tracking algorithm with the full CIDER algorithm (ANN and cross model). This flag assumes that you have loaded the ANN parameters into the binary file using build_param_file.py, along with the FPN masks for the eye-facing camera at least. Out-facing FPN mask is not technically necessary but recommended nonetheless.

The results of the CIDER algorithm for eye tracking will be stored along with the images. usb_image.py will look for these data automatically, if you are using unpack_images.py you must manually set the --model-data flag.

Setting ANN_MODE or CIDER_MODE forces the following flags to be set:
->EYE_CAM_PRIMARY
->USE_PARAM_FILE
->COLUMN_COLLECT



----------------------------Firmware Architecture------------------------------

Here is a very brief overview of the firmware architecture. (TODO: Finish this)